<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
  <title>setIcon (SFML::Window)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/* call-seq:
 *   window.setIcon( width, height, pixels )
 *
 * Change the window's icon.
 *
 * pixels must be an array of width x height pixels in 32-bits RGBA format. In the ruby binding the array will be
 * flattened so you can have array's up to 3 dimensions(or more) to represent each pixel component. The size of the
 * array will be assumed to be width * height * 4.
 *
 * The OS default icon is used by default.
 * 
 * Usage example:
 *   pixels = [
 *     [[255, 0, 0, 255], [0, 0, 255, 255]],
 *     [[0, 255, 0, 255], [0, 0, 0, 255]]
 *   ]
 *   
 *   window.setIcon( 2, 2, pixels )
 */
static VALUE Window_SetIcon( VALUE self, VALUE aWidth, VALUE aHeight, VALUE somePixels )
{
        const unsigned int rawWidth = FIX2UINT( aWidth );
        const unsigned int rawHeight = FIX2UINT( aHeight );
        VALIDATE_CLASS( somePixels, rb_cArray, &quot;third&quot; );
        const unsigned long dataSize = rawWidth * rawHeight * 4;
        sf::Uint8 * const tempData = new sf::Uint8[dataSize];
        VALUE pixels = rb_funcall( somePixels, rb_intern(&quot;flatten&quot;), 0 );
        for(unsigned long index = 0; index &lt; dataSize; index++)
        {
                sf::Uint8 val = NUM2CHR( rb_ary_entry( pixels, index ) );
                tempData[index] = val;
        }
        
        sf::Window *object = NULL;
        Data_Get_Struct( self, sf::Window, object );
        object-&gt;SetIcon( rawWidth, rawHeight, tempData );
        delete[] tempData;
        return Qnil;
}</pre>
</body>
</html>